<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shitcoin Showdown</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            margin-bottom: 30px;
            font-size: 3em;
        }
        
        .setup-screen, .game-screen, .recap-screen {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #00ff88;
            font-weight: bold;
        }
        
        textarea, input {
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #00ff88;
            border-radius: 8px;
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        
        textarea {
            min-height: 120px;
            resize: vertical;
        }
        
        input[type="number"] {
            width: 200px;
        }
        
        button {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #1a1a2e;
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        

/* REPLACE WITH: */
.coin-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 20px;
    margin-top: 30px;
}

@media (max-width: 1400px) {
    .coin-grid {
        grid-template-columns: repeat(4, 1fr);
        gap: 15px;
    }
}

@media (max-width: 1100px) {
    .coin-grid {
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
    }
}

@media (max-width: 768px) {
    .coin-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
    }
}

@media (max-width: 480px) {
    .coin-grid {
        grid-template-columns: 1fr;
        gap: 10px;
    }
}
        
        .coin-card {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1) 0%, rgba(0, 204, 102, 0.05) 100%);
            border: 2px solid #00ff88;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        .coin-card.winner {
            border-color: #ffd700;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 215, 0, 0.1) 100%);
		}
		
		/* REPLACE WITH: */
		.coin-card.leading {
			border-color: #8b5cf6;
			background: linear-gradient(135deg, rgba(139, 92, 246, 0.3) 0%, rgba(139, 92, 246, 0.15) 100%);
			box-shadow: 0 0 30px rgba(139, 92, 246, 0.5);
		}      
        .coin-card.rugged {
            border-color: #ff0066;
            background: linear-gradient(135deg, rgba(255, 0, 102, 0.2) 0%, rgba(255, 0, 102, 0.1) 100%);
            opacity: 0.6;
        }
        
        .coin-card.eliminated {
            border-color: #8b4513;
            background: linear-gradient(135deg, rgba(139, 69, 19, 0.2) 0%, rgba(139, 69, 19, 0.1) 100%);
            opacity: 0.5;
        }
        
        .coin-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
        }
        
        .player-name {
            font-size: 14px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 15px;
        }
        
        .coin-name {
            font-size: 17px;
			font-weight:bold;
            color: #88ffdd;
            margin-bottom: 5px;
        }
        
        .coin-value {
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            text-align: center;
        }
        
        .coin-change {
            text-align: center;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .positive { color: #00ff88; }
        .negative { color: #ff0066; }
				
		.rug-label {
			background: #8B0000; /* dark red */
			color: #fff;
			padding: 5px 10px;
			border-radius: 5px;
			font-size: 11px;
			font-weight: bold;
			display: inline-block;
			margin-top: 10px;
		}
        
        .eliminated-label {
            background: #8b4513;
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
            display: inline-block;
            margin-top: 10px;
        }
        
        .pop-note {
            background: #ffd700;
            color: #1a1a2e;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 11px;
            font-weight: bold;
            display: inline-block;
            margin-top: 10px;
        }
        
        .pop-graphic {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 40px;
            animation: popAnimation 2s ease-out;
            pointer-events: none;
            z-index: 10;
        }
        
        @keyframes popAnimation {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }
        
        .round-info {
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
            color: #00ff88;
        }
        
        .timer {
            text-align: center;
            font-size: 48px;
            color: #ffd700;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        .timer.countdown {
            font-size: 72px;
            color: #ff0066;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .hidden {
            display: none;
        }
        
        .recap-list {
            list-style: none;
            padding: 0;
        }
        
        .recap-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 5px solid #00ff88;
        }
        
        .recap-item:first-child {
            border-left-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
        }
        
        .rank {
            font-size: 32px;
            font-weight: bold;
            color: #ffd700;
            margin-right: 20px;
        }
        
        .coin-info-text {
            margin: 5px 0;
            font-size: 12px;
            color: #88ffdd;
        }
        
        .input-row {
            display: flex;
            gap: 20px;
        }
        
        .input-row .input-group {
            flex: 1;
        }
		@media (max-width: 768px) {
    body {
        padding: 10px;
    }
    
    h1 {
        font-size: 2em;
        margin-bottom: 20px;
    }
    
    .setup-screen, .game-screen, .recap-screen {
        padding: 20px;
    }
    
    .input-row {
        flex-direction: column;
        gap: 0;
    }
    
    .coin-card {
        padding: 15px;
    }
    
    .player-name {
        font-size: 13px;
        margin-bottom: 10px;
    }
    
    .coin-name {
        font-size: 14px;
    }
    
    .coin-value {
        font-size: 20px;
    }
    
    .timer {
        font-size: 36px;
    }
    
    .timer.countdown {
        font-size: 48px;
    }
    
    .round-info {
        font-size: 18px;
    }
    
    button {
        padding: 12px 30px;
        font-size: 16px;
    }
    
    .rank {
        font-size: 24px;
    }
    
    .recap-item {
        padding: 15px;
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
    }
}

@media (max-width: 480px) {
    h1 {
        font-size: 1.5em;
    }
    
    .coin-card {
        padding: 12px;
    }
    
    .player-name {
        font-size: 12px;
    }
    
    .coin-name {
        font-size: 13px;
    }
    
    .coin-value {
        font-size: 18px;
    }
    
    textarea {
        min-height: 100px;
    }
    
    input[type="number"] {
        width: 100%;
    }
}
		
		
    </style>
</head>
<body>
    <div class="container">
        <h1>üí∞ SHITCOIN SHOWDOWN üí∞</h1>
        
        <div id="setupScreen" class="setup-screen">
            <div class="input-group">
                <label for="players">Enter Players (one per line):</label>
                <textarea id="players" placeholder="Alice&#10;Bob&#10;Charlie"></textarea>
            </div>
            
            <div class="input-row">
                <div class="input-group">
                    <label for="numDays">Number of Days:</label>
                    <input type="number" id="numDays" value="120" min="1" max="600">
                </div>
                
                <div class="input-group">
                    <label for="roundSeconds">Seconds Per Round:</label>
                    <input type="number" id="roundSeconds" value="30" min="10" max="600">
                </div>
            </div>
            
            <div class="input-group">
                <label for="coinNames">Coin Names (one per line - optional):</label>
                <textarea id="coinNames" placeholder="Leave empty for auto-generated names"></textarea>
            </div>
            
            <button id="startGameBtn">Start Game</button>
        </div>
        
        <div id="gameScreen" class="game-screen hidden">
            <div class="round-info">
               <!-- <div>Round <span id="currentRound">1</span> of <span id="totalRounds">1</span></div>  -->
                <div>Group <span id="currentGroup">1</span> of <span id="totalGroups">1</span></div>
            </div>
            <div class="timer" id="timer">15</div>
			<button id="startRoundBtn">Start Round</button>
			<button id="continueRoundBtn" style="display:none;">Continue</button>
            <div class="coin-grid" id="coinGrid"></div>
        </div>
        
        <div id="recapScreen" class="recap-screen hidden">
            <h2 style="text-align: center; margin-bottom: 30px; color: #ffd700;">üèÜ Final Results üèÜ</h2>
            <ol class="recap-list" id="recapList"></ol>
            <button id="resetGameBtn" style="display: block; margin: 30px auto 0;">Play Again</button>
        </div>
    </div>
    
    <script>
        let gameState = {
            players: [],
            groups: [],
            currentGroupIndex: 0,
            salt: '',
            coinNames: [],
            usedCoinNames: new Set(),
            winners: [],
            roundActive: false,
            totalGameTime: 0,
            iteration: 0,
            roundNumber: 1,
            maxIterations: 0,
            roundSeconds: 15,
            eliminationSchedule: [],
            iterationsPerDay: 0,
            ruggedThisPeriod: false,
            lastEliminationCheck: 0,
			baseSize : 0
        };
        

        const firstNames = ['Gyro','Hero', 'Spider','Wonk','Splif','Gansta', 'Prank', 'Poop',
    'Glimpse','Shudder','Quiver','Waver','Falter','Lurch','Stagger','Sway','Teeter','Totter',
    'Slither','Skulk','Slink','Scurry','Scuttle','Skitter','Caper','Prance','Lope','Bound',
    'Bristle','Buckle','Crinkle','Wrinkle','Pucker','Ripple','Quake','Tremor','Rumble','Roil',
    'Churn','Swirl','Eddy','Gyre','Maelstrom','Cyclone','Whorl','Spiral','Helix','Loop',
    'Glisten','Glaze','Luster','Sheen','Patina','Tarnish','Oxide','Corrode','Erode','Pitted',
    'Sputter','Spatter','Splatter','Dribble','Trickle','Drizzle','Sluice','Cascade','Deluge','Downpour',
    'Globule','Droplet','Pellet','Granule','Powder','Flake','Shard','Chip','Sliver','Fragment',
    'Wisp','Plume','Billow','Curl','Coalesce','Diffuse','Dissolve','Evaporate','Condense','Sublime',
    'Feral','Savage','Wild','Rabid','Manic','Deranged','Unhinged','Errant','Wayward','Rogue',
    'Gremlin','Imp','Wretch','Fiend','Goblin','Ghoul','Banshee','Wraith','Poltergeist','Djinn',
    'Talisman','Amulet','Phylactery','Grimoire','Codex','Scroll','Tome','Idol','Effigy','Fetish',
    'Augury','Divination','Portent','Harbinger','Premonition','Revelation','Epiphany','Mirage','Illusion','Phantasm',
    'Trance','Stupor','Delirium','Rapture','Euphoria','Ecstasy','Frenzy','Hysteria','Meltdown','Overload',
    'Static','Crosstalk','Feedback','Interference','Distortion','Aberration','Anomaly','Artifact','Residual','Afterimage',
    'Sludge','Goo','Gunk','Ichor','Pulp','Paste','Residue','Sediment','Dreg','Slurry',
    'Ember','Cinder','Spark','Kindle','Ignite','Scorch','Char','Singe','Blister','Smolder',
    'Chill','Frost','Rime','Glacier','Permafrost','Cryo','Numb','Shiver','Tingle','Prickle',
    'Oracle','Seer','Prophet','Visionary','Dreamer','Nomad','Drifter','Wanderer','Vagrant','Pilgrim',
    'Moon','Rocket','Diamond','Gold','Laser','Turbo','Mega','Ultra','Super','Hyper',
    'Quantum','Cyber','Crypto','Doge','Elon','Pepe','Wojak','Chad','Based','Giga',
    'Ooze','Fizzle','Glitch','Slime','Smog','Froth','Miasma','Glimmer','Sizzle','Plasma',
    'Gloop','Vapor','Fuzz','Flux','Drift','Blur','Haze','Mist','Echo','Pulse',
    'Throb','Wobble','Jitter','Shimmer','Crackle','Pop','Fizz','Slosh','Gush','Spill',
    'Seep','Smear','Stain','Smudge','Warp','Twist','Bend','Coil','Knot','Snarl',
    'Tangle','Snag','Hook','Jab','Poke','Prod','Blink','Stare','Gaze','Smirk',
    'Drool','Frolic','Wheeze','Giggle','Snicker','Chuckle','Gnash','Chomp','Nibble','Munch',
    'Slurp','Gulp','Chew','Gnaw','Lick','Sip','Twitch','Writhe','Squirm','Creep',
    'Crawl','Scoot','Slide','Slip','Snap','Crack','Fracture','Shear','Splinter','Grind',
    'Press','Squeeze','Mash','Melt','Morph','Mutant','Shift','Phase','Float','Hover',
    'Sink','Glow','Gleam','Shine','Flare','Flash'
		
		];
        const lastNames = ['Coin', 'Token', 'Cash', 'Bucks', 'Money', 'Finance', 'Protocol', 'Network', 'Chain', 'Swap', 'Vault', 'Pump', 'Gains', 'Safe',

    'Coin','Token','Proof','Hash','Nonce','Cipher','Key','Lock','Seal','Vault',
    'Ledger','Chain','Block','Node','Oracle','Trust','Stake','Yield','Mint','Burn',
    'Gas','Asset','Value','Bond','Note','Share','Unit','Index','Rate','Limit',
    'Bound','Curve','Scalar','Vector','Prime','Root','Field','Ring','Group','Basis',
    'Entropy','Signal','Verify','Auth','Secure','Guard','Shield','Control' 
];
        
        function generateSalt() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hour = String(now.getHours()).padStart(2, '0');
            const minute = String(now.getMinutes()).padStart(2, '0');
            const second = String(now.getSeconds()).padStart(2, '0');
            return `${year}_${month}_${day}_${hour}_${minute}_${second}`;
        }
				
		function generateCoinNames(count, baseSize) {
			const names = [];
			 let usedParts = new Set();

			for (let i = 0; i < count; i++) {
				let coinName;
				const rand = Math.random();

				if ((i % baseSize) == 0)
				{
					  usedParts = new Set();
				}

				let first1 = '!';
				let first2 = '!';
				let last = '!';

				while (
					first1 === first2 || first1 === last || first2 === last ||
					usedParts.has(first1) || usedParts.has(first2) || usedParts.has(last)
				) {
					// if (usedParts.has(last))
					first1 = firstNames[Math.floor(Math.random() * firstNames.length)];
					first2 = firstNames[Math.floor(Math.random() * firstNames.length)];
					last = lastNames[Math.floor(Math.random() * lastNames.length)];
					//alert(first1 + '|' + first2 + '|' + last)
					//alert(groupCount)
					//console.log(usedParts)
				}

				usedParts.add(first1);
				usedParts.add(first2);
				usedParts.add(last);

				if (rand < 0.005) {
					coinName = `${first1}${last}${first2}`;
				} else if (rand < 0.03) {
					coinName = `${first1}${first2}${last}`;
				} else if (rand < 0.04) {
					coinName = `${first1}${first2}`;
				} else {
					coinName = `${first1}${last}`;
				}

				names.push(coinName);

			}

			return names;
		}
        
        function normalizePlayer(name) {
            return name.toLowerCase().replace(/[^a-z0-9]/g, '');
        }
        
        function hashPlayer(player, salt) {
            return CryptoJS.MD5(player + salt).toString();
        }
        
        function hashIteration(player, salt, iteration, round) {
            const hashInput = `${player}_${salt}_${iteration}_${round}`;
            return CryptoJS.MD5(hashInput).toString();
        }
        
        function hashToNumber(hash) {
            const hex = hash.substring(0, 8);
            const num = parseInt(hex, 16);
            return num / 0xffffffff;
        }
        
        function createGroups(players, salt) {
            const normalized = [...new Set(players.map(p => normalizePlayer(p.trim())).filter(p => p))];
            
            const hashed = normalized.map(p => ({
                original: players.find(pl => normalizePlayer(pl.trim()) === p),
                normalized: p,
                hash: hashPlayer(p, salt)
            }));
            
            hashed.sort((a, b) => a.hash.localeCompare(b.hash));
            
            const groupCount = Math.max(1, Math.ceil(hashed.length / 15));
            const baseSize = Math.floor(hashed.length / groupCount);
            const remainder = hashed.length % groupCount;
            
            const groups = [];
            let index = 0;
            
            for (let i = 0; i < groupCount; i++) {
                const size = baseSize + (i < remainder ? 1 : 0);
                groups.push(hashed.slice(index, index + size));
                index += size;
            }
            
            return {groups, baseSize};
        }
        
        function getUnusedCoinName() {
            const available = gameState.coinNames.filter(name => !gameState.usedCoinNames.has(name));
            if (available.length === 0) {
                return generateCoinNames(1, 1)[0];
            }
            const name = available[Math.floor(Math.random() * available.length)];
            gameState.usedCoinNames.add(name);
            return name;
        }
        
        function bellCurve() {
            let u = 0, v = 0;
            while (u === 0) u = Math.random();
            while (v === 0) v = Math.random();
            const num = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            return num / 10.0 + 0.515;
        }
        
        function startGame() {
            const playersText = document.getElementById('players').value;
            const numDays = parseInt(document.getElementById('numDays').value);
            const roundSeconds = parseInt(document.getElementById('roundSeconds').value);
            const coinNamesText = document.getElementById('coinNames').value;
			
 
            
            if (!playersText.trim()) {
                alert('Please enter at least one player');
                return;
            }
            
            if (numDays < 1) {
                alert('Please enter at least 1 day');
                return;
            }
            
            if (roundSeconds < 15) {
                alert('Please enter at least 15 seconds');
                return;
            }
            
			

            
			const players = playersText.split('\n').filter(p => p.trim());
			const salt = generateSalt();
			
			const { groups, baseSize } = createGroups(players, salt);
			gameState.groups = groups;
			gameState.baseSize = baseSize;		
            const coinNames = coinNamesText.trim() ? 
                coinNamesText.split('\n').filter(n => n.trim()) : 
                generateCoinNames(400, gameState.baseSize);
            
 
			const iterationsPerSecond = Math.min(numDays / roundSeconds, 10);
			const maxIterations = Math.floor(numDays * 1.1);
					
            gameState.players = players;
            gameState.salt = salt;
            gameState.coinNames = coinNames;

            gameState.currentGroupIndex = 0;
            gameState.winners = [];
            gameState.usedCoinNames = new Set();
            gameState.totalGameTime = 0;
            gameState.maxIterations = maxIterations;
            gameState.roundSeconds = roundSeconds;
            gameState.roundNumber = 1;
            // gameState.iterationsPerDay = iterationsPerDay;
			gameState.iterationsPerSecond = iterationsPerSecond;      
			
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            // document.getElementById('totalRounds').textContent = gameState.groups.length;
            document.getElementById('totalGroups').textContent = gameState.groups.length;
            document.getElementById('timer').textContent = roundSeconds;
            
            setupRound();
        }
        
        function setupRound() {
            const group = gameState.groups[gameState.currentGroupIndex];
            const coins = group.map(player => ({
                player: player.original,
                normalized: player.normalized,
                coinName: getUnusedCoinName(),
                value: 1.0,
                rugged: false,
                eliminated: false,
                popped: false,
                popPercent: 0
            }));
						
			const totalIterations = gameState.roundSeconds * gameState.iterationsPerSecond;
			const numPlayers = coins.length;
			const shitPercent = 0.15; // Roughly 15% of the days
			const numEliminations = Math.max(0, coins.length - 1);
			const eliminationSchedule = [];

			const iterationsPerElimination = Math.floor(totalIterations * shitPercent);
			for (let i = 0; i < numEliminations; i++) {
				const eliminationIteration = (i + 1) * iterationsPerElimination;
				eliminationSchedule.push(eliminationIteration);
			}
            
            gameState.currentCoins = coins;
            gameState.iteration = 0;
            gameState.eliminationSchedule = eliminationSchedule;
            gameState.currentRoundIterations = totalIterations;
            gameState.ruggedThisPeriod = false;
            gameState.lastEliminationCheck = 0;
            
            // document.getElementById('currentRound').textContent = gameState.currentGroupIndex + 1;
            document.getElementById('currentGroup').textContent = gameState.currentGroupIndex + 1;
            document.getElementById('startRoundBtn').style.display = 'block';
            document.getElementById('timer').textContent = gameState.roundSeconds;
            document.getElementById('timer').classList.remove('countdown');
            
            renderCoins();
        }
        
        function renderCoins() {
            const grid = document.getElementById('coinGrid');
						
			const active = gameState.currentCoins.filter(c => !c.rugged && !c.eliminated);
			const rugged = gameState.currentCoins.filter(c => c.rugged);
			const eliminated = gameState.currentCoins.filter(c => c.eliminated);

			active.sort((a, b) => b.value - a.value);
			const leadingCoin = active.length > 0 ? active[0] : null;           
            
			active.sort((a, b) => b.value - a.value);
            rugged.sort((a, b) => b.value - a.value);
            eliminated.sort((a, b) => b.value - a.value);
            
            const sorted = [...active, ...rugged, ...eliminated];
            
            grid.innerHTML = '';
						
			gameState.winners.forEach(winner => {
				const card = document.createElement('div');
				card.className = 'coin-card winner';
				v1 = formatNumber(winner.value);
				card.innerHTML = `
					<div class="coin-name">${winner.coinName}</div>
					<div class="player-name">${winner.player}</div>
					<div class="coin-value">$${v1}</div>
					<div class="coin-info-text">Previous Round Winner</div>
				`;
				grid.appendChild(card);
			});
						
			sorted.forEach(coin => {
				const card = document.createElement('div');
				const isLeading = leadingCoin && coin === leadingCoin;
				card.className = `coin-card ${coin.rugged ? 'rugged' : ''} ${coin.eliminated ? 'eliminated' : ''} ${isLeading ? 'leading' : ''}`;
                card.innerHTML = `
				    <div class="coin-name">${coin.coinName}</div>
                    <div class="player-name">${coin.player}</div>

<div class="coin-value">${coin.eliminated ? 'üí©' : '$' + formatNumber(coin.value)}</div>
                    ${coin.rugged ? '<div class="rug-label">üö® RUGGED üö®</div>' : ''}
                    ${coin.eliminated ? '<div class="eliminated-label">üí© SHIT üí©</div>' : ''}
                    ${coin.popped ? `<div class="pop-note">üéâ POP +${coin.popPercent}% üéâ</div>` : ''}
                `;
                if (coin.showPopGraphic) {
                    const popGraphic = document.createElement('div');
                    popGraphic.className = 'pop-graphic';
                    popGraphic.textContent = 'üí•';
                    card.appendChild(popGraphic);
                }
                grid.appendChild(card);
            });
        }
        
        function startRound() {
            if (gameState.roundActive) return;
            
            gameState.roundActive = true;
            document.getElementById('startRoundBtn').style.display = 'none';
            
            let timeLeft = gameState.roundSeconds;
            const totalIterations =  gameState.roundSeconds * 10;
            let shouldReorder = false;
            
            const timerInterval = setInterval(() => {
                timeLeft--;
                const timerEl = document.getElementById('timer');
                timerEl.textContent = timeLeft;
                
                if (timeLeft <= 5 && timeLeft > 0) {
                    timerEl.classList.add('countdown');
                } else {
                    timerEl.classList.remove('countdown');
                }
                
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    clearInterval(updateInterval);
                    endRound();
                }
            }, 1000);
            
	// const iterationsPerSecond =  Math.min(Math.ceil(gameState.numDays / gameState.roundSeconds), 60); // Math.ceil(gameState.maxIterations / gameState.roundSeconds);
	const iterationsPerSecond = gameState.iterationsPerSecond;		
	const intervalMs = 1000 / iterationsPerSecond;

	const updateInterval = setInterval(() => {
  
                gameState.iteration++;
                const iterationProgress = gameState.iteration / totalIterations;
                

 
				const reorderInterval = Math.floor(iterationsPerSecond * 5); // Every 5 seconds
				const inLastFiveSeconds = timeLeft <= 5;

				if (inLastFiveSeconds || (reorderInterval > 0 && gameState.iteration % reorderInterval === 0)) {
					shouldReorder = true;
				} else {
					shouldReorder = false;
				}
								
				const nextElimination = gameState.eliminationSchedule.find(e => e > gameState.lastEliminationCheck && e <= gameState.iteration);
				if (nextElimination) {
					if (!gameState.ruggedThisPeriod) {
						eliminateWorstCoin();
					}
					gameState.ruggedThisPeriod = false;
					gameState.lastEliminationCheck = gameState.iteration;
				}
                
                gameState.currentCoins.forEach(coin => {
                    coin.showPopGraphic = false;
                    
                    if (coin.rugged || coin.eliminated) return;
										
					const currentDay = Math.floor(gameState.iteration / gameState.iterationsPerSecond);
					if (currentDay > gameState.maxIterations) return;

					const totalGameSeconds = gameState.iteration / gameState.iterationsPerSecond;
					const popChance = (gameState.iterationsPerSecond / 10) / 150; // lower for higher chances
					const rugChance = (gameState.iterationsPerSecond / 10) / 150;// lower for higher chances

					const rand1 = Math.random();
					const rand2 = Math.random();

					if (rand1 < popChance && !coin.popped) {
                        const popIncrease = 1 + (Math.random() * 9 + 1);
                        coin.value *= popIncrease;
                        coin.popped = true;
                        coin.popPercent = Math.round((popIncrease - 1) * 100);
                        coin.showPopGraphic = true;
                    } else if (rand2 < rugChance) {
                        coin.rugged = true;
                        gameState.ruggedThisPeriod = true;
                    } else {
                        const hash = hashIteration(coin.normalized, gameState.salt, gameState.iteration, gameState.roundNumber);
                        const hashNum = hashToNumber(hash);
                        
                        const bellValue = bellCurve();
                        const combined = (hashNum + bellValue) / 2;
                        
                        const percent = (combined - 0.5) * 1.8;
                        coin.value *= (1 + percent);
                        coin.value = Math.max(0.0001, coin.value);
                    }
                });
								

				const active = gameState.currentCoins.filter(c => !c.rugged && !c.eliminated);
				active.sort((a, b) => b.value - a.value);
				const currentLeader = active.length > 0 ? active[0] : null;

				// Update leading class on all cards
				const allCards = document.querySelectorAll('.coin-card:not(.winner)');
				allCards.forEach(card => {
					const playerName = card.querySelector('.player-name').textContent;
					const coin = gameState.currentCoins.find(c => c.player === playerName);
					if (coin && currentLeader && coin === currentLeader) {
						card.classList.add('leading');
					} else {
						card.classList.remove('leading');
					}
				});

				if (shouldReorder) {
					renderCoins();
				} else {
					updateCoinValues();
				}
            }, intervalMs);
        }
        
        function updateCoinValues() {
            const cards = document.querySelectorAll('.coin-card:not(.winner)');
            cards.forEach((card, index) => {
                const coin = gameState.currentCoins.find(c => 
                    card.querySelector('.player-name').textContent === c.player
                );
                if (coin) {
                    const valueEl = card.querySelector('.coin-value');
                    valueEl.textContent = coin.eliminated ? 'üí©' : `$${formatNumber(coin.value)}`;
                    
                    if (coin.showPopGraphic && !card.querySelector('.pop-graphic')) {
                        const popGraphic = document.createElement('div');
                        popGraphic.className = 'pop-graphic';
                        popGraphic.textContent = 'üí•';
                        card.appendChild(popGraphic);
                    }
                }
            });
        }
        
        function eliminateWorstCoin() {
            const eligible = gameState.currentCoins.filter(c => !c.rugged && !c.eliminated);
            if (eligible.length <= 1) return;
            
            const worst = eligible.reduce((min, coin) => coin.value < min.value ? coin : min);
            worst.eliminated = true;
            worst.value = 0;
        }
        
        function endRound() {
            gameState.roundActive = false;
            

			const validCoins = gameState.currentCoins.filter(c => !c.rugged && !c.eliminated);
			if (validCoins.length > 0) {
				// Find max value
				const maxValue = Math.max(...validCoins.map(c => c.value));
				
				// Get all coins tied at max value
				const tiedCoins = validCoins.filter(c => c.value === maxValue);
				
				if (tiedCoins.length > 1) {
					// Rug all but the one with lowest MD5 hash for this iteration
					const withHashes = tiedCoins.map(coin => ({
						coin,
						hash: hashIteration(coin.normalized, gameState.salt, gameState.iteration, gameState.roundNumber)
					}));
					
					withHashes.sort((a, b) => a.hash.localeCompare(b.hash));
					const winner = withHashes[0].coin;
					
					// Rug the others
					withHashes.slice(1).forEach(item => {
						item.coin.rugged = true;
					});
					
					gameState.winners.push({...winner});
				} else {
					gameState.winners.push({...tiedCoins[0]});
				}
			}
            
            gameState.currentGroupIndex++;
            gameState.roundNumber++;
						
			if (gameState.currentGroupIndex < gameState.groups.length) {
				// Show Continue button
				const continueBtn = document.getElementById('continueRoundBtn');
				continueBtn.style.display = 'block';
			} else {
				setTimeout(() => showRecap(), 2000);
			}
        }
        
        function showRecap() {
            document.getElementById('gameScreen').classList.add('hidden');
            document.getElementById('recapScreen').classList.remove('hidden');
            
            const sorted = [...gameState.winners].sort((a, b) => b.value - a.value);
            const list = document.getElementById('recapList');
            list.innerHTML = '';
            
            sorted.forEach((winner, index) => {
                const item = document.createElement('li');
                item.className = 'recap-item';
                item.innerHTML = `
                    <div style="display: flex; align-items: center;">
                        <div class="rank">#${index + 1}</div>
                        <div>
                            <div style="font-size: 20px; font-weight: bold;">${winner.player}</div>
                            <div style="color: #88ffdd;">${winner.coinName}</div>
                        </div>
                    </div>
                    <div style="font-size: 24px; font-weight: bold; color: #00ff88;">${formatNumber(winner.value)}</div>
                `;
                list.appendChild(item);
            });
        }
        
        function resetGame() {
            document.getElementById('recapScreen').classList.add('hidden');
            document.getElementById('setupScreen').classList.remove('hidden');
            gameState = {
                players: [],
                groups: [],
                currentGroupIndex: 0,
                salt: '',
                coinNames: [],
                usedCoinNames: new Set(),
                winners: [],
                roundActive: false,
                totalGameTime: 0,
                iteration: 0,
                roundNumber: 1,
                maxIterations: 0,
                roundSeconds: 15,
                eliminationSchedule: [],
                iterationsPerDay: 0,
                ruggedThisPeriod: false,
                lastEliminationCheck: 0
            };
        }
        
        document.getElementById('startGameBtn').addEventListener('click', startGame);
        document.getElementById('startRoundBtn').addEventListener('click', startRound);
        document.getElementById('resetGameBtn').addEventListener('click', resetGame);
		document.getElementById('continueRoundBtn').addEventListener('click', () => {
			const continueBtn = document.getElementById('continueRoundBtn');
			continueBtn.style.display = 'none';
			setupRound();
		});

		// REPLACE WITH:
		function formatNumber(value) {
			const decimals = value >= 100 ? 2 : 4;
			return new Intl.NumberFormat('en-US', {
				minimumFractionDigits: decimals,
				maximumFractionDigits: decimals
			}).format(value);
		}

    </script>
</body>
</html>