<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BOP Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: #1e3a5f;
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            font-size: 3em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .setup-screen, .game-screen {
            background: #2d5a7b;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            border: 2px solid #3d7a9f;
        }
        
        .input-section {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            font-size: 1.2em;
            font-weight: bold;
        }
        
        textarea {
            width: 100%;
            padding: 15px;
            border-radius: 10px;
            border: none;
            font-size: 1em;
            min-height: 150px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
        }
        
        button {
            background: #16a34a;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            font-weight: bold;
            border: 2px solid #15803d;
        }
        
        button:hover {
            background: #15803d;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        
        .round-info {
            display: none;
        }
        
        .game-stats {
            background: #1e4d6b;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 0.9em;
            border: 2px solid #3d7a9f;
        }
        
        .game-stats div {
            margin: 5px 0;
        }
        
        .game-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        @media (min-width: 768px) {
            .game-container {
                grid-template-columns: 300px 1fr;
            }
        }
        
        .emoji-picker {
            text-align: center;
            background: #1e4d6b;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            height: fit-content;
            border: 2px solid #3d7a9f;
        }
        
        .emoji-display {
            font-size: 4em;
            margin: 15px 0;
            animation: bounce 0.5s ease;
        }
        
        .emoji-name {
            font-size: 0.9em;
            margin-top: 5px;
            opacity: 0.9;
        }
        
        .current-players {
            margin-top: 15px;
            font-size: 0.9em;
            background: #16425b;
            padding: 10px;
            border-radius: 10px;
            border: 1px solid #3d7a9f;
        }
        
        .current-players h4 {
            margin-bottom: 5px;
            font-size: 0.95em;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        
        .draw-button {
            margin-top: 15px;
        }
        
        .cards-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .player-card {
            background: #3a6d8c;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.3s ease;
            border: 2px solid #4a8db0;
        }
        
        .player-card:hover {
            transform: translateY(-5px);
        }
        
        .player-card.close-to-win {
            background: #06b6d4;
            box-shadow: 0 0 20px rgba(6, 182, 212, 0.8);
            animation: closeWinPulse 1.5s ease-in-out infinite;
            border: 3px solid #0891b2;
        }
        
        @keyframes closeWinPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(6, 182, 212, 0.8); }
            50% { box-shadow: 0 0 30px rgba(6, 182, 212, 1); }
        }
        
        .player-card.winner {
            background: #16a34a;
            animation: winnerGlow 1s ease-in-out infinite;
            border: 3px solid #15803d;
        }
        
        @keyframes winnerGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(22, 163, 74, 0.8); }
            50% { box-shadow: 0 0 40px rgba(22, 163, 74, 1); }
        }
        
        .player-name {
            text-align: center;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .bop-header {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-bottom: 5px;
        }
        
        .bop-letter {
            text-align: center;
            font-weight: bold;
            font-size: 1.5em;
            padding: 5px;
            background: #2d5a7b;
            border-radius: 5px;
            border: 2px solid #3d7a9f;
        }
        
        .bop-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }
        
        .bop-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            background: #4a8db0;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #5a9dc0;
        }
        
        .bop-cell.marked {
            background: #f59e0b;
            transform: scale(0.95);
            border: 2px solid #d97706;
        }
        
        .winner-announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #16a34a;
            padding: 50px;
            border-radius: 20px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
            text-align: center;
            z-index: 1000;
            animation: popIn 0.5s ease;
            border: 3px solid #15803d;
        }
        
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        
        .winner-announcement h2 {
            font-size: 3em;
            margin-bottom: 20px;
        }
        
        .called-emojis {
            margin-top: 15px;
            text-align: center;
        }
        
        .called-emojis h4 {
            font-size: 0.95em;
            margin-bottom: 10px;
        }
        
        .called-emoji {
            display: inline-block;
            font-size: 1.5em;
            margin: 3px;
            padding: 3px;
            background: #16425b;
            border-radius: 8px;
            border: 1px solid #3d7a9f;
        }
        
        @media (max-width: 768px) {
            h1 { font-size: 2em; }
            .cards-container { grid-template-columns: 1fr; }
            .bop-cell { font-size: 1.5em; }
            .emoji-display { font-size: 3em; }
            .game-container { grid-template-columns: 1fr; }
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé± BOP GAME üé±</h1>
        
        <div id="setupScreen" class="setup-screen">
            <div class="input-section">
                <label for="playerInput">Enter Players (one per line):</label>
                <textarea id="playerInput" placeholder="Player 1&#10;Player 2&#10;Player 3&#10;..."></textarea>
            </div>
            <button onclick="startGame()">Start Game</button>
        </div>
        
        <div id="gameScreen" class="game-screen hidden">
            <div class="round-info">
                <div id="roundInfo"></div>
            </div>
            
            <div class="game-container">
                <div class="emoji-picker">
                    <div class="game-stats" id="gameStats"></div>
                    <h3>Emoji Picker</h3>
                    <div class="emoji-display" id="emojiDisplay">‚ùì</div>
                    <div class="emoji-name" id="emojiName"></div>
                    <button class="draw-button" onclick="drawEmoji()" id="drawButton">Draw Emoji!</button>
                    <div class="current-players" id="currentPlayers"></div>
                    <div class="called-emojis" id="calledEmojis"></div>
                </div>
                
                <div class="cards-container" id="cardsContainer"></div>
            </div>
        </div>
    </div>

    <script>
        const emojiNames = {
    // Faces
    'üòÄ': 'Grinning',
    'üòÉ': 'Happy',
    'üòÑ': 'Smile',
    'üòÅ': 'Grin',
    'üòÜ': 'Laugh',
    'üòÇ': 'Laughing',
    'ü§£': 'Hysterical',
    'üòä': 'Blush',
    'üòá': 'Innocent',
    'üôÇ': 'Content',
    'üôÉ': 'Upside Down',
    'üòâ': 'Wink',
    'üòå': 'Relieved',
    'üòç': 'Love',
    'ü•∞': 'Affection',
    'üòò': 'Kiss',
    'üòó': 'Peck',
    'üòô': 'Kissy',
    'üòö': 'Smooch',
    'üòã': 'Yummy',
    'üòú': 'Tease',
    'ü§™': 'Crazy',
    'üòù': 'Mock',
    'ü§ë': 'Greedy',
    'ü§ó': 'Hug',
    'ü§≠': 'Oops',
    'ü§´': 'Quiet',
    'ü§î': 'Thinking',
    'ü§©': 'Amazed',
    'üòé': 'Cool',
    'ü•≥': 'Party',
    'üòè': 'Smug',
    'üòí': 'Annoyed',
    'üôÑ': 'Eye Roll',
    'üò¨': 'Awkward',
    'ü§ê': 'Silent',
    'üò¥': 'Sleepy',
    'ü§§': 'Drooling',
    'üò™': 'Tired',
    'üòµ': 'Dizzy',
    'ü§Ø': 'Mind Blown',
    'üò±': 'Fear',
    'ü•∂': 'Cold',
    'ü•µ': 'Hot',
    'üòà': 'Mischief',
    'üëª': 'Ghost',
    'ü§°': 'Clown',

    // Animals (basic names only)
    'üê∂': 'Dog',
    'üê±': 'Cat',
    'üê≠': 'Mouse',
    'üêπ': 'Hamster',
    'üê∞': 'Rabbit',
    'ü¶ä': 'Fox',
    'üêª': 'Bear',
    'üêº': 'Panda',
    'üê®': 'Koala',
    'üêØ': 'Tiger',
    'ü¶Å': 'Lion',
    'üêÆ': 'Cow',
    'üê∑': 'Pig',
    'üê∏': 'Frog',
    'üêµ': 'Monkey',
    'üêî': 'Chicken',
    'üêß': 'Penguin',
    'üê¶': 'Bird',
    'üê∫': 'Wolf',
    'ü¶Ñ': 'Unicorn',
    'ü¶ì': 'Zebra',
    'ü¶í': 'Giraffe',
    'üêó': 'Boar',
    'üê¥': 'Horse',
    'ü¶å': 'Deer',
    'üê¢': 'Turtle',
    'üêç': 'Snake',
    'ü¶é': 'Lizard',
    'üêô': 'Octopus',
    'ü¶ë': 'Squid',
    'ü¶û': 'Lobster',
    'ü¶Ä': 'Crab',
    'üê°': 'Blowfish',
    'üê†': 'Fish',
    'üê¨': 'Dolphin',
    'üê≥': 'Whale',
    'ü¶à': 'Shark',
    'üêä': 'Crocodile',
    'üêò': 'Elephant',
    'ü¶è': 'Rhinoceros',
    'ü¶õ': 'Hippopotamus',
    'üê™': 'Camel',
    'ü¶ç': 'Gorilla',
    'ü¶ß': 'Orangutan',
    'ü¶ò': 'Kangaroo',
    'ü¶¨': 'Bison',
    'ü¶•': 'Sloth',

    // Other
    'üî•': 'Fire',
    '‚ö°': 'Lightning',
    'üåü': 'Star',
    'üíé': 'Gem',
    'üö®': 'Alarm',
    'üéØ': 'Target',
    'üé®': 'Paint',
    'üé≠': 'Theater',
    'üé™': 'Circus',
    'üé∏': 'Guitar',
    'üöÄ': 'Rocket',
    '‚öΩ': 'Soccer',
    'üéÆ': 'Game',
    'üçï': 'Pizza',
    'üåà': 'Rainbow',
    'üí•': 'Impact',
    'üí£': 'Bomb',
    'üèÜ': 'Trophy',
    'ü•á': 'Medal',
    'üé≤': 'Dice',
    'üß†': 'Brain',
    'üïπÔ∏è': 'Joystick',
    'üì°': 'Satellite',
    'üîÆ': 'Crystal',
    'üéÉ': 'Pumpkin',
    'üéÜ': 'Fireworks',
    'üéá': 'Sparkler',
    'üîë': 'Key',
    'üß≤': 'Magnet',
    '‚öôÔ∏è': 'Gear',
    'üõ†Ô∏è': 'Tools',
    'üß±': 'Brick',
    'ü™ô': 'Coin',
    'üí∞': 'Money',
    'üì¶': 'Box',
    'üß≥': 'Luggage',
    '‚è±Ô∏è': 'Timer',
    'üß≠': 'Compass',
    'üó∫Ô∏è': 'Map'
};

const ListB = [
    'üòÄ','üòÉ','üòÑ','üòÅ','üòÜ','üòÇ','ü§£','üòä','üòá','üôÇ',
    'üôÉ','üòâ','üòå','üòç','ü•∞','üòò','üòó','üòô','üòö','üòã',
    'üòú','ü§™','üòù','ü§ë','ü§ó','ü§≠','ü§´','ü§î','ü§©','üòé',
    'ü•≥','üòè','üòí','üôÑ','üò¨','ü§ê','üò¥','ü§§','üò™','üòµ',
    'ü§Ø','üò±','ü•∂','ü•µ','üòà','üëª','ü§°'
];

const ListO = [
    'üê∂','üê±','üê≠','üêπ','üê∞','ü¶ä','üêª','üêº','üê®','üêØ',
    'ü¶Å','üêÆ','üê∑','üê∏','üêµ','üêî','üêß','üê¶','üê∫','ü¶Ñ',
    'ü¶ì','ü¶í','üêó','üê¥','ü¶å','üê¢','üêç','ü¶é','üêô','ü¶ë',
    'ü¶û','ü¶Ä','üê°','üê†','üê¨','üê≥','ü¶à','üêä','üêò','ü¶è',
    'ü¶õ','üê™','ü¶ç','ü¶ß','ü¶ò','ü¶¨','ü¶•'
];

const ListP = [
    'üî•','‚ö°','üåü','üíé','üö®','üéØ','üé®','üé≠','üé™','üé∏',
    'üöÄ','‚öΩ','üéÆ','üçï','üåà','üí•','üí£','üèÜ','ü•á','üé≤',
    'üß†','üïπÔ∏è','üì°','üîÆ','üéÉ','üéÜ','üéá','üîë','üß≤','‚öôÔ∏è',
    'üõ†Ô∏è','üß±','ü™ô','üí∞','üì¶','üß≥','‚è±Ô∏è','üß≠','üó∫Ô∏è'
];
        
        let salt = '';
        let gameState = {
            allPlayers: [],
            currentGame: 0,
            totalGames: 0,
            allWinners: [],
            games: [],
            drawNumber: 0,
            calledEmojis: [],
            emojiPool: [],
            availableEmojis: []
        };
        
        function generateSalt() {
            const now = new Date();
            const ss = String(now.getSeconds()).padStart(2, '0');
            const mm = String(now.getMinutes()).padStart(2, '0');
            const hh = String(now.getHours()).padStart(2, '0');
            const dd = String(now.getDate()).padStart(2, '0');
            const MM = String(now.getMonth() + 1).padStart(2, '0');
            const yyyy = now.getFullYear();
            return `${ss}^${mm}^${hh}^${dd}^${MM}^${yyyy}`;
        }
        
        function normalizePlayer(name) {
            return name.toLowerCase().replace(/[^a-z0-9]/g, '');
        }
        
        function hashPlayer(player, salt) {
            return CryptoJS.MD5(normalizePlayer(player) + salt).toString();
        }
        
        function createGroups(players, salt) {
            const hashed = players.map(p => ({
                name: p,
                hash: hashPlayer(p, salt)
            })).sort((a, b) => a.hash.localeCompare(b.hash));
            
            const n = hashed.length;
            const numGroups = Math.ceil(n / 6);
            const baseSize = Math.floor(n / numGroups);
            const remainder = n % numGroups;
            
            const groups = [];
            let idx = 0;
            
            for (let i = 0; i < numGroups; i++) {
                const size = baseSize + (i < remainder ? 1 : 0);
                groups.push(hashed.slice(idx, idx + size).map(p => p.name));
                idx += size;
            }
            
            return groups;
        }
        
        function generateEmojiPool(listB, listO, listP) {
            const pickN = (list, n) => {
                const shuffled = [...list].sort(() => Math.random() - 0.5);
                return shuffled.slice(0, Math.min(n, list.length));
            };
            
            return {
                B: pickN(listB, 15),
                O: pickN(listO, 15),
                P: pickN(listP, 15)
            };
        }
        
        function generateCard(pool) {
            const card = [];
            // Each column (B, O, P) gets 3 unique emojis from its pool
            for (let row = 0; row < 3; row++) {
                ['B', 'O', 'P'].forEach(letter => {
                    const availableEmojis = pool[letter].filter(e => !card.includes(e));
                    if (availableEmojis.length === 0) {
                        // If we've used all emojis from this pool, allow reuse
                        const randomIdx = Math.floor(Math.random() * pool[letter].length);
                        card.push(pool[letter][randomIdx]);
                    } else {
                        const randomIdx = Math.floor(Math.random() * availableEmojis.length);
                        card.push(availableEmojis[randomIdx]);
                    }
                });
            }
            // Rearrange so columns are correct: indices 0,3,6 = B; 1,4,7 = O; 2,5,8 = P
            const correctOrder = [
                card[0], card[1], card[2],  // Row 1: B, O, P
                card[3], card[4], card[5],  // Row 2: B, O, P
                card[6], card[7], card[8]   // Row 3: B, O, P
            ];
            return correctOrder;
        }
        
        function seededRandom(seed) {
            const hash = CryptoJS.MD5(seed).toString();
            const num = parseInt(hash.substring(0, 8), 16);
            return num / 0xffffffff;
        }
        
        function pickEmoji(pool, drawNum, salt) {
            const allEmojis = [...pool.B, ...pool.O, ...pool.P];
            const seed = salt + '^' + drawNum;
            const rand = seededRandom(seed);
            const idx = Math.floor(rand * allEmojis.length);
            return allEmojis[idx];
        }
        
        function checkWin(card, marked) {
            // Check rows
            for (let i = 0; i < 3; i++) {
                if (marked[i*3] && marked[i*3+1] && marked[i*3+2]) return true;
            }
            // Check columns
            for (let i = 0; i < 3; i++) {
                if (marked[i] && marked[i+3] && marked[i+6]) return true;
            }
            // Check diagonals
            if (marked[0] && marked[4] && marked[8]) return true;
            if (marked[2] && marked[4] && marked[6]) return true;
            // Check 4 corners
            if (marked[0] && marked[2] && marked[6] && marked[8]) return true;
            
            return false;
        }
        
        function checkCloseToWin(card, marked) {
            let closeCount = 0;
            
            // Check rows for 2 out of 3
            for (let i = 0; i < 3; i++) {
                const rowMarked = [marked[i*3], marked[i*3+1], marked[i*3+2]].filter(Boolean).length;
                if (rowMarked === 2) closeCount++;
            }
            
            // Check columns for 2 out of 3
            for (let i = 0; i < 3; i++) {
                const colMarked = [marked[i], marked[i+3], marked[i+6]].filter(Boolean).length;
                if (colMarked === 2) closeCount++;
            }
            
            // Check diagonals for 2 out of 3
            const diag1Marked = [marked[0], marked[4], marked[8]].filter(Boolean).length;
            if (diag1Marked === 2) closeCount++;
            
            const diag2Marked = [marked[2], marked[4], marked[6]].filter(Boolean).length;
            if (diag2Marked === 2) closeCount++;
            
            // Check 4 corners for 3 out of 4
            const cornersMarked = [marked[0], marked[2], marked[6], marked[8]].filter(Boolean).length;
            if (cornersMarked === 3) closeCount++;
            
            return closeCount > 0;
        }
        
        function startGame() {
            const input = document.getElementById('playerInput').value;
            let players = input.split('\n').map(p => p.trim()).filter(p => p.length > 0);
            
            // Remove duplicates
            const normalized = new Map();
            players.forEach(p => {
                const norm = normalizePlayer(p);
                if (!normalized.has(norm)) {
                    normalized.set(norm, p);
                }
            });
            players = Array.from(normalized.values());
            
            if (players.length < 2) {
                alert('Please enter at least 2 players!');
                return;
            }
            
            salt = generateSalt();
            gameState.allPlayers = players;
            gameState.currentGame = 0;
            gameState.allWinners = [];
            gameState.games = [];
            
            // Create Round 1 games
            const round1Groups = createGroups(players, salt + '_round_0');
            round1Groups.forEach((group, idx) => {
                gameState.games.push({
                    gameNumber: gameState.games.length,
                    roundNumber: 1,
                    players: group,
                    cards: {},
                    marked: {},
                    winner: null
                });
            });
            
            // Plan out subsequent rounds (we'll fill in player names as winners are determined)
            let currentRoundSize = round1Groups.length;
            let roundNum = 2;
            
            while (currentRoundSize > 1) {
                const nextRoundGroups = createGroups(
                    new Array(currentRoundSize).fill('temp'), 
                    salt + '_round_' + roundNum
                );
                
                nextRoundGroups.forEach(() => {
                    gameState.games.push({
                        gameNumber: gameState.games.length,
                        roundNumber: roundNum,
                        players: [], // Will be filled with winners
                        cards: {},
                        marked: {},
                        winner: null
                    });
                });
                
                currentRoundSize = nextRoundGroups.length;
                roundNum++;
            }
            
            gameState.totalGames = gameState.games.length;
            
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('gameScreen').classList.remove('hidden');
            
            startCurrentGame();
        }
        
        function startCurrentGame() {
            const game = gameState.games[gameState.currentGame];
            
            // Safety check: if players array is empty or has placeholder values, skip
            if (!game.players || game.players.length === 0 || game.players.some(p => !p || p === 'temp' || p === 'placeholder')) {
                console.error('Game has invalid players:', game.players);
                // Try to find next valid game
                gameState.currentGame++;
                if (gameState.currentGame < gameState.totalGames) {
                    startCurrentGame();
                }
                return;
            }
            
            gameState.drawNumber = 0;
            gameState.calledEmojis = [];
            gameState.availableEmojis = [];
            
            gameState.emojiPool = generateEmojiPool(ListB, ListO, ListP);
            
            // Generate unique cards for each player
            game.players.forEach(player => {
                game.cards[player] = generateCard(gameState.emojiPool);
                game.marked[player] = Array(9).fill(false);
            });
            
            // Available emojis are all from the pool
            gameState.availableEmojis = [...gameState.emojiPool.B, ...gameState.emojiPool.O, ...gameState.emojiPool.P];
            
            displayGame();
        }
        
        function displayGame() {
            const game = gameState.games[gameState.currentGame];
            
            // Safety check
            if (!game || !game.players || game.players.length === 0) {
                console.error('Cannot display game - invalid game state');
                return;
            }
            
            const currentRound = game.roundNumber;
            const isChampionship = gameState.currentGame === gameState.totalGames - 1;
            
            // Calculate total rounds
            const maxRound = Math.max(...gameState.games.map(g => g.roundNumber));
            const roundText = isChampionship ? 'Championship' : `Round ${currentRound}`;
            const totalRoundsText = maxRound > 1 ? ` (${maxRound} rounds total)` : '';
            
            document.getElementById('gameStats').innerHTML = `
                <div><strong>Game ${gameState.currentGame + 1} of ${gameState.totalGames}</strong></div>
                <div>${roundText}${totalRoundsText}</div>
            `;
            
            document.getElementById('emojiDisplay').textContent = '‚ùì';
            document.getElementById('emojiName').textContent = '';
            document.getElementById('calledEmojis').innerHTML = '';
            document.getElementById('currentPlayers').innerHTML = '';
            document.getElementById('drawButton').disabled = false;
            
            const container = document.getElementById('cardsContainer');
            container.innerHTML = '';
            
            // Display each player's unique card
            game.players.forEach(player => {
                const card = game.cards[player];
                const marked = game.marked[player];
                
                if (!card || card.length !== 9) {
                    console.error(`Invalid card for player ${player}:`, card);
                    return;
                }
                
                const cardDiv = document.createElement('div');
                cardDiv.className = 'player-card';
                cardDiv.id = `card-${player}`;
                
                cardDiv.innerHTML = `
                    <div class="player-name">${player}</div>
                    <div class="bop-header">
                        <div class="bop-letter">B</div>
                        <div class="bop-letter">O</div>
                        <div class="bop-letter">P</div>
                    </div>
                    <div class="bop-grid">
                        ${card.map((emoji, idx) => `
                            <div class="bop-cell ${marked[idx] ? 'marked' : ''}" 
                                 data-player="${player}" data-idx="${idx}">
                                ${emoji}
                            </div>
                        `).join('')}
                    </div>
                `;
                
                container.appendChild(cardDiv);
            });
        }
        
        function drawEmoji() {
            // Filter out already called emojis
            const uncalledEmojis = gameState.availableEmojis.filter(e => !gameState.calledEmojis.includes(e));
            
            if (uncalledEmojis.length === 0) {
                alert('All emojis have been called! No winner this game.');
                return;
            }
            
            gameState.drawNumber++;
            
            // Pick from uncalled emojis only
            const seed = salt + '^' + gameState.drawNumber;
            const rand = seededRandom(seed);
            const idx = Math.floor(rand * uncalledEmojis.length);
            const emoji = uncalledEmojis[idx];
            
            gameState.calledEmojis.push(emoji);
            
            document.getElementById('emojiDisplay').textContent = emoji;
            document.getElementById('emojiName').textContent = emojiNames[emoji] || '';
            document.getElementById('emojiDisplay').style.animation = 'none';
            setTimeout(() => {
                document.getElementById('emojiDisplay').style.animation = 'bounce 0.5s ease';
            }, 10);
            
            const calledDiv = document.getElementById('calledEmojis');
            calledDiv.innerHTML = '<h4>Called:</h4>' + 
                gameState.calledEmojis.map(e => `<span class="called-emoji">${e}</span>`).join('');
            
            // Mark cards and track players with this emoji
            const game = gameState.games[gameState.currentGame];
            const winners = [];
            const playersWithEmoji = [];
            
            game.players.forEach(player => {
                const card = game.cards[player];
                let hasEmoji = false;
                card.forEach((cardEmoji, idx) => {
                    if (cardEmoji === emoji) {
                        hasEmoji = true;
                        game.marked[player][idx] = true;
                        const cell = document.querySelector(
                            `.bop-cell[data-player="${player}"][data-idx="${idx}"]`
                        );
                        if (cell) cell.classList.add('marked');
                    }
                });
                
                if (hasEmoji) {
                    playersWithEmoji.push(player);
                }
                
                // Check if player won
                if (checkWin(card, game.marked[player])) {
                    winners.push(player);
                    document.getElementById(`card-${player}`).classList.add('winner');
                } else if (checkCloseToWin(card, game.marked[player])) {
                    // Check if player is close to winning
                    const playerCard = document.getElementById(`card-${player}`);
                    if (playerCard && !playerCard.classList.contains('winner')) {
                        playerCard.classList.add('close-to-win');
                    }
                }
            });
            
            // Show players who have this emoji
            if (playersWithEmoji.length > 0) {
                document.getElementById('currentPlayers').innerHTML = 
                    '<h4>Players with this emoji:</h4>' + playersWithEmoji.join(', ');
            } else {
                document.getElementById('currentPlayers').innerHTML = 
                    '<h4>No players have this emoji</h4>';
            }
            
            if (winners.length > 0) {
                game.winner = winners.length === 1 ? winners[0] : winners;
                winners.forEach(w => gameState.allWinners.push(w));
                document.getElementById('drawButton').disabled = true;
                setTimeout(() => announceWinner(winners), 1000);
            }
        }
        
        function announceWinner(winners) {
            const announcement = document.createElement('div');
            announcement.className = 'winner-announcement';
            
            const winnersList = Array.isArray(winners) ? winners : [winners];
            const winnersText = winnersList.length === 1 
                ? winnersList[0] 
                : winnersList.slice(0, -1).join(', ') + ' and ' + winnersList[winnersList.length - 1];
            
            // Check if this is the final game AND there's only one winner
            const isLastGame = gameState.currentGame === gameState.totalGames - 1;
            const isSingleChampion = winnersList.length === 1;
            
            if (isLastGame && isSingleChampion) {
                // Single winner in final game - TRUE CHAMPION
                announcement.innerHTML = `
                    <h2>üèÜ CHAMPION! üèÜ</h2>
                    <h3>${winnersText} wins the tournament!</h3>
                    <button onclick="location.reload()">Play Again</button>
                `;
            } else if (isLastGame && !isSingleChampion) {
                // Multiple winners in final game - NEED TIEBREAKER
                announcement.innerHTML = `
                    <h2>üéä TIE! üéä</h2>
                    <h3>${winnersText} tied in the Championship!</h3>
                    <p>Creating sudden-death tiebreaker...</p>
                    <button id="tiebreakerBtn" onclick="createTiebreaker(${JSON.stringify(winnersList).replace(/"/g, '&quot;')})">
                        Play Tiebreaker
                    </button>
                `;
                
                // Add spacebar listener for tiebreaker
                setTimeout(() => {
                    const handleTiebreakerKey = (e) => {
                        if (e.code === 'Space' || e.key === ' ') {
                            e.preventDefault();
                            document.removeEventListener('keydown', handleTiebreakerKey);
                            createTiebreaker(winnersList);
                        }
                    };
                    document.addEventListener('keydown', handleTiebreakerKey);
                }, 100);
            } else {
                // Regular game win
                const gameWinText = winnersList.length === 1 
                    ? `${winnersText} wins this game!`
                    : `${winnersText} win this game!`;
                announcement.innerHTML = `
                    <h2>üéä BOP! üéä</h2>
                    <h3>${gameWinText}</h3>
                    <button id="continueBtn" onclick="nextGame()">Continue to Next Game</button>
                `;
                
                // Add spacebar listener for continue
                setTimeout(() => {
                    const handleContinueKey = (e) => {
                        if (e.code === 'Space' || e.key === ' ') {
                            e.preventDefault();
                            document.removeEventListener('keydown', handleContinueKey);
                            nextGame();
                        }
                    };
                    document.addEventListener('keydown', handleContinueKey);
                }, 100);
            }
            
            document.body.appendChild(announcement);
        }
        
        function createTiebreaker(tiedPlayers) {
            document.querySelector('.winner-announcement').remove();
            
            // Validate tiedPlayers
            if (!Array.isArray(tiedPlayers) || tiedPlayers.length < 2) {
                console.error('Invalid tiebreaker players:', tiedPlayers);
                alert('Error creating tiebreaker. Declaring co-champions.');
                return;
            }
            
            // Get the highest round number currently in the tournament
            const maxRound = Math.max(...gameState.games.map(g => g.roundNumber));
            
            // Create a new sudden-death tiebreaker game
            const tiebreakerGame = {
                gameNumber: gameState.games.length,
                roundNumber: maxRound + 1,
                players: tiedPlayers,
                cards: {},
                marked: {},
                winner: null
            };
            
            gameState.games.push(tiebreakerGame);
            gameState.totalGames = gameState.games.length;
            gameState.currentGame = gameState.games.length - 1;
            
            console.log(`Created tiebreaker game for ${tiedPlayers.length} players:`, tiedPlayers);
            
            // Start the tiebreaker
            startCurrentGame();
        }
        
        function nextGame() {
            document.querySelector('.winner-announcement').remove();
            
            gameState.currentGame++;
            
            // Check if we've finished all games
            if (gameState.currentGame >= gameState.totalGames) {
                return; // Tournament complete
            }
            
            // Get current game to check if it needs player assignment
            let currentGame = gameState.games[gameState.currentGame];
            
            // If current game has no players or placeholder players, we need to populate from previous round winners
            if (!currentGame.players || currentGame.players.length === 0 || 
                currentGame.players.some(p => !p || p === 'temp' || p === 'placeholder')) {
                
                const currentRound = currentGame.roundNumber;
                
                // Collect ALL winners from the previous round
                const previousRoundGames = gameState.games.filter(g => g.roundNumber === currentRound - 1);
                const previousRoundWinners = [];
                
                previousRoundGames.forEach(game => {
                    if (game.winner) {
                        if (Array.isArray(game.winner)) {
                            // Multiple winners from this game
                            previousRoundWinners.push(...game.winner);
                        } else {
                            // Single winner
                            previousRoundWinners.push(game.winner);
                        }
                    }
                });
                
                console.log(`Round ${currentRound}: Collected ${previousRoundWinners.length} winners from ${previousRoundGames.length} games`);
                console.log('Winners:', previousRoundWinners);
                
                // Check if all previous round games are complete
                const allPreviousGamesComplete = previousRoundGames.every(g => g.winner !== null);
                
                if (!allPreviousGamesComplete) {
                    console.log('Not all previous round games complete, continuing to next game');
                    startCurrentGame();
                    return;
                }
                
                // Remove duplicates (just in case)
                const uniqueWinners = [...new Set(previousRoundWinners)];
                
                // Expected winners is number of games in previous round
                const expectedWinners = previousRoundGames.length;
                
                if (uniqueWinners.length !== expectedWinners) {
                    console.log(`RESTRUCTURING: Expected ${expectedWinners} winners, got ${uniqueWinners.length}`);
                    
                    // Remove all unplayed games from current round onwards
                    gameState.games = gameState.games.filter(g => 
                        g.roundNumber < currentRound || g.winner !== null
                    );
                    
                    // Rebuild tournament structure from current round
                    let remainingPlayers = uniqueWinners;
                    let roundNum = currentRound;
                    
                    while (remainingPlayers.length > 1) {
                        const groups = createGroups(remainingPlayers, salt + '_round_' + roundNum + '_v2');
                        
                        console.log(`Creating Round ${roundNum} with ${groups.length} games:`, groups);
                        
                        groups.forEach((group) => {
                            gameState.games.push({
                                gameNumber: gameState.games.length,
                                roundNumber: roundNum,
                                players: group,
                                cards: {},
                                marked: {},
                                winner: null
                            });
                        });
                        
                        // Prepare for next iteration
                        remainingPlayers = new Array(groups.length).fill('temp');
                        roundNum++;
                    }
                    
                    gameState.totalGames = gameState.games.length;
                    gameState.currentGame = gameState.games.findIndex(g => g.winner === null);
                    
                    console.log(`Restructured. Total games now: ${gameState.totalGames}, Current game: ${gameState.currentGame}`);
                    
                } else {
                    // Expected number of winners - distribute to games in current round
                    console.log('Expected number of winners, distributing normally');
                    
                    const gamesInThisRound = gameState.games.filter(g => g.roundNumber === currentRound);
                    const groups = createGroups(uniqueWinners, salt + '_round_' + currentRound);
                    
                    console.log(`Distributing ${uniqueWinners.length} players to ${groups.length} games:`, groups);
                    
                    groups.forEach((group, idx) => {
                        if (gamesInThisRound[idx]) {
                            gamesInThisRound[idx].players = group;
                            console.log(`Game ${gamesInThisRound[idx].gameNumber} assigned players:`, group);
                        }
                    });
                }
            }
            
            // Start the current game (after potential restructuring)
            if (gameState.currentGame < gameState.totalGames) {
                startCurrentGame();
            }
        }
    </script>
</body>
</html>